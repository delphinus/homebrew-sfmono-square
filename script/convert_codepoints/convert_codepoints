#!/usr/bin/env perl

=head1 NAME

convert_codepoints

=head1 SYNOPSIS

    # convert files from v2 => v3 (default values)
    % bin/convert_codepoints

    # specify versions
    % bin/convert_codepoints -f v1 -t v3

=head1 DESCRIPTION

This is a script to convert glyphs in your dotfiles according to versions of SF
Mono Square. Now this font has 3 versions that has some codepoints without
compatibility. This script can search any file in the current directory and
convert characters that have such codepoints according to supplied options.

Here is an outline of changes in v1, v2, v3, nerd-fonts v2 and nerd-fonts v3.

=head2 v1

Material glyphs in U+F500 .. U+F8FF and U+E800 .. U+EC46. They overwrites Apple
glyphs (U+F6D5 .. U+F6D8, U+F8FF), so v1 has no such ones.

Also, there are no glyphs from Codicons.

=head2 v2

To use Apple glyphs, some glyphs in Material have moved.

    U+F6D5 .. U+F6D8 => U+FF6D5 .. U+FF6D8
    U+F8FF => U+FF8FF

So this time Material glyphs in U+F500 .. U+F6D4, U+FF6D5 .. U+FF6D8, U+F6D9 =>
U+F8FE, U+E800 .. U+EC46.

Now v2 has Codicons glyphs in U+FEA60 .. U+FEBEB not to overwrite Material ones.

=head2 v3

v3 uses completely the same codepoints as nerd-fonts v3 ones.

Material => U+F0001 .. U+F1AF0
Apple    => U+F6D5 .. U+F6D8, U+F8FF
Codicons => U+EA60 .. U+EBEB

=head2 nerd-fonts v2

nerd-fonts v2 has errros on codepoints. That overwrites some codepoints except
PUA (Private USE Area - U+E000 .. U+F8FF).

=head2 nerd-fonts v3

This solves errors above. It uses the same as L</v3>.

=head1 OPTIONS

    --from, -f [version]    This specifies a version string to convert from.
                            This accepts "v1", "v2", "v3", "nerd_fonts_v2" or
                            "nerd_fonts_v3". "nerd_fonts_XX" means the
                            codepoints from nerd-fonts. Default: "v2"
    --to, -t [version]      This is the one to convert to. Default: "v3"
    --dry-run, -n           Dry-run. With this, it prints the diff only.

=head1 COPYRIGHT & LICENSE

JINNOUCHI Yasushi <me@delphinus.dev>

MIT License

=cut

use strict;
use warnings;
use feature qw(say state);
use Data::Dumper;
use Getopt::Long qw(:config posix_default no_ignore_case bundling auto_help);
use List::Util qw(reduce);
use Pod::Usage qw(pod2usage);

GetOptions(
    \my %opt, qw(
        from|f=s
        to|t=s
        dry-run|n
    ),
) or pod2usage(1);

$opt{from} //= 'v2';
$opt{to} //= 'v3';

sub is_valid_version($) {
    my ($v) = @_;
    defined $v && $v =~ /\A(?:nerd_fonts_[23]|v[123])\z/;
}

pod2usage(2) if !is_valid_version $opt{from} or !is_valid_version $opt{to};

my %map_cache;
sub code_map($) {
    my ($name) = @_;

    # creates a map like this below.
    # +{
    #   Material => +{ 0xf500 => 0, 0xf501 => 1, ... , reverse => +{ 0 => 0xf500, ... } },
    #   Codicons => +{ 0xea60 => 0, 0xea61 => 1, ... , reverse => +{ 0 => 0xea60, ... } },
    #   Apple => +{ 0xf6d5 => 0, 0xf6d6 = . 1, ... , reverse => +{ 0 => f6d5, ... } },
    # }
    state $create_map = sub {
        my ($name) = @_;

        my %glyphs = (
            nerd_fonts_v2 => {
                Material => [0xf500 .. 0xfd46],
                Apple => undef,
                Codicons => undef,
            },

            nerd_fonts_v3 => {
                Material => [0xf0001 .. 0xf1af0],
                Apple => [0xf6d5 .. 0xf6d8, 0xf8ff],
                Codicons => [0xea60 .. 0xebeb],
            },

            v1 => {
                Material => [0xf500 .. 0xf8ff, 0xe800 .. 0xec47],
                Apple => undef,
                Codicons => undef,
            },

            v2 => {
                Material => [0xf500 .. 0xf6d4, 0xff6d5 .. 0xff6d8, 0xf6d9 .. 0xf8fe, 0xff8ff, 0xe800 .. 0xec46],
                Apple => [0xf6d5 .. 0xf6d8, 0xf8ff],
                Codicons => [0xfea60 .. 0xfebeb],
            },

            # same as nerd_fonts_v3
            v3 => {
                Material => [0xf0001 .. 0xf1af0],
                Apple => [0xf6d5 .. 0xf6d8, 0xf8ff],
                Codicons => [0xea60 .. 0xebeb],
            },
        );

        reduce {
            my $codes = $glyphs{$name}{$b};
            if (defined $codes) {
                my $code_map = $a->{$b} = +{};
                for (my $i = 0; $i < @$codes; $i++) {
                    $code_map->{$codes->[$i]} = $i;
                }
                $code_map->{reverse} = +{reverse %$code_map};
            }
            $a;
        } +{}, keys %{$glyphs{$name}},
    };

    $map_cache{$name} //= $create_map->($name);
}


sub search_index($$) {
    my ($code_map, $char) = @_;

    my $code = ord $char;
    while (my ($k, $v) = each %$code_map) {
        if (defined $v->{$code}) {
            return $k, $v->{$code};
        }
    }
    undef;
}

sub search_result($$$) {
    my ($code_map, $name, $index) = @_;

    defined $code_map->{$name} ? $code_map->{$name}{reverse}{$index} : undef;
}

sub convert($$$) {
    my ($char, $from, $to) = @_;

    my $from_map = code_map $from;
    my $to_map = code_map $to;

    my ($name, $index) = search_index $from_map, $char;
    defined $name ? search_result $to_map, $name, $index : undef;
}

sub main() {
    my $converted = convert chr(0xf6d5), 'v3', 'v1';
    if (defined $converted) {
        say sprintf '%04X', $converted;
    } else {
        say 'None';
    }
}

main if $0 eq __FILE__;
